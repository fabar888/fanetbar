<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二维码扫描页面</title>
    <style>
        /* 移除所有样式，让服务端返回的HTML完全控制样式 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        /* 加载提示样式 */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 18px;
            font-family: Arial, "Microsoft YaHei", sans-serif;
            z-index: 9999;
        }
        #loading.hidden {
            display: none;
        }
        /* 错误提示样式 */
        #error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
        }
        #error.show {
            display: flex;
        }
        .error-content {
            background: white;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-width: 600px;
            margin: 20px;
        }
        .error-content h1 {
            color: #f56c6c;
            margin-bottom: 20px;
            font-family: Arial, "Microsoft YaHei", sans-serif;
        }
        .error-content p {
            color: #666;
            line-height: 1.6;
            font-family: Arial, "Microsoft YaHei", sans-serif;
        }
        /* 内容区域 - 完全由服务端HTML控制，不添加任何样式 */
        #content {
            /* 不设置任何样式，让服务端HTML完全控制 */
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>正在加载二维码页面...</div>
    </div>
    <div id="error">
        <div class="error-content">
            <h1>⚠️ 加载失败</h1>
            <p id="error-message">无法从服务器获取页面内容</p>
        </div>
    </div>
    <div id="content"></div>

    <script>
        // 配置：后端服务器地址
        const BACKEND_SERVER = 'https://bar.zzzzxyz.xyz:8443';
        // 注意：如果服务器有路径前缀（如 /app），需要在这里添加
        // 如果服务器API在 /app/api 下，设置为 '/app'
        // 如果服务器API直接在 /api 下，设置为 ''
        const API_BASE_PATH = '/app'; // 根据你的服务器配置修改这里
        
        // 从URL获取设备自定义ID（custom_id）
        function getCustomIdFromUrl() {
            const path = window.location.pathname;
            const pathParts = path.split('/').filter(p => p);
            
            // 支持格式: /device/{customId} 或 /{customId}
            if (pathParts.length === 1 && pathParts[0] !== 'index.html') {
                return pathParts[0];
            } else if (pathParts.length === 2 && pathParts[0] === 'device') {
                return pathParts[1];
            }
            
            // 如果没有自定义ID，尝试从查询参数获取
            const params = new URLSearchParams(window.location.search);
            return params.get('custom_id') || params.get('id') || null; // 不再使用默认值，必须提供custom_id
        }
        
        // 带超时的 fetch 请求
        function fetchWithTimeout(url, options = {}, timeout = 10000) {
            return new Promise((resolve, reject) => {
                const timer = setTimeout(() => {
                    reject(new Error(`请求超时（${timeout}ms）。可能是网络连接问题或服务器无响应。`));
                }, timeout);
                
                fetch(url, options)
                    .then(response => {
                        clearTimeout(timer);
                        resolve(response);
                    })
                    .catch(error => {
                        clearTimeout(timer);
                        reject(error);
                    });
            });
        }
        
        // 从后端服务器获取页面内容
        async function loadQRPage() {
            const customId = getCustomIdFromUrl();
            
            // 如果没有提供custom_id，显示错误
            if (!customId) {
                document.getElementById('loading').classList.add('hidden');
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('error-message');
                errorMessage.innerHTML = '请在URL中提供设备自定义ID（custom_id）<br><br>格式：<code>?custom_id=你的自定义ID</code> 或 <code>/你的自定义ID</code>';
                errorDiv.classList.add('show');
                return;
            }
            
            // 构建完整的API URL（使用custom_id而不是数字ID）
            const apiUrl = `${BACKEND_SERVER}${API_BASE_PATH}/api/qr_page_by_custom_id/${encodeURIComponent(customId)}`;
            
            console.log('正在请求:', apiUrl);
            console.log('当前页面URL:', window.location.href);
            console.log('后端服务器:', BACKEND_SERVER);
            console.log('API基础路径:', API_BASE_PATH);
            
            try {
                // 使用带超时的 fetch（10秒超时）
                const response = await fetchWithTimeout(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/html',
                    },
                    mode: 'cors', // 明确指定CORS模式
                    credentials: 'omit', // 不发送 cookies
                }, 10000);
                
                console.log('响应状态:', response.status, response.statusText);
                console.log('响应头:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    throw new Error(`服务器返回错误: ${response.status} ${response.statusText}\n${errorText.substring(0, 200)}`);
                }
                
                const html = await response.text();
                
                if (!html || html.trim().length === 0) {
                    throw new Error('服务器返回了空内容');
                }
                
                console.log('成功获取HTML内容，长度:', html.length);
                
                // 隐藏加载提示
                document.getElementById('loading').classList.add('hidden');
                
                // 解析服务端返回的HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // 提取服务端HTML的head中的style标签，添加到当前页面的head
                const serverStyles = doc.head.querySelectorAll('style');
                serverStyles.forEach(style => {
                    // 检查是否已存在相同的style（避免重复）
                    const existingStyles = document.head.querySelectorAll('style');
                    let exists = false;
                    existingStyles.forEach(existing => {
                        if (existing.textContent === style.textContent) {
                            exists = true;
                        }
                    });
                    if (!exists) {
                        const newStyle = document.createElement('style');
                        newStyle.textContent = style.textContent;
                        document.head.appendChild(newStyle);
                    }
                });
                
                // 获取服务端HTML的body内容
                const serverBody = doc.body;
                const contentDiv = document.getElementById('content');
                
                if (serverBody) {
                    // 清空content div
                    contentDiv.innerHTML = '';
                    
                    // 将服务端body的所有子元素移动到content div
                    // 这样服务端的HTML结构（包括.container等）会完全保留
                    while (serverBody.firstChild) {
                        contentDiv.appendChild(serverBody.firstChild);
                    }
                } else {
                    // 如果没有body标签，直接使用HTML内容
                    contentDiv.innerHTML = html;
                }
                
                // 显示内容（content div本身没有样式，完全由服务端HTML控制）
                contentDiv.style.display = 'block';
                
            } catch (error) {
                console.error('加载失败:', error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                // 隐藏加载提示
                document.getElementById('loading').classList.add('hidden');
                
                // 显示详细错误信息
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('error-message');
                
                let errorText = `无法从服务器获取页面内容\n\n`;
                errorText += `错误类型: ${error.name}\n`;
                errorText += `错误信息: ${error.message}\n\n`;
                errorText += `请求地址: ${apiUrl}\n\n`;
                
                // 根据错误类型给出不同的提示
                if (error.message.includes('超时') || error.message.includes('timeout')) {
                    errorText += `⚠️ 请求超时。可能的原因：\n`;
                    errorText += `1. 后端服务器未运行或无法访问\n`;
                    errorText += `2. 网络连接问题\n`;
                    errorText += `3. 服务器响应太慢\n\n`;
                    errorText += `请检查：\n`;
                    errorText += `- 后端服务器是否正常运行\n`;
                    errorText += `- 服务器地址是否正确: ${BACKEND_SERVER}\n`;
                    errorText += `- 网络连接是否正常`;
                } else if (error.message.includes('CORS') || error.message.includes('fetch') || error.name === 'TypeError') {
                    errorText += `⚠️ 这可能是跨域（CORS）问题或网络错误。\n\n`;
                    errorText += `可能的原因：\n`;
                    errorText += `1. 后端服务器未正确配置CORS头\n`;
                    errorText += `2. 后端服务器使用自签名SSL证书，浏览器阻止了请求\n`;
                    errorText += `3. 网络连接失败\n\n`;
                    errorText += `解决方法：\n`;
                    errorText += `1. 检查后端服务器是否允许来自 GitHub Pages 域名的请求\n`;
                    errorText += `2. 确认API路径是否正确（可能需要 /app 前缀）\n`;
                    errorText += `3. 如果使用自签名证书，需要先在浏览器中直接访问 API URL 并接受证书\n`;
                    errorText += `4. 打开浏览器控制台（F12）查看详细错误信息\n`;
                    errorText += `5. 尝试直接访问: ${apiUrl}`;
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorText += `⚠️ 网络请求失败。\n\n`;
                    errorText += `可能的原因：\n`;
                    errorText += `1. 后端服务器未运行\n`;
                    errorText += `2. 服务器地址配置错误\n`;
                    errorText += `3. SSL证书问题（自签名证书）\n`;
                    errorText += `4. 防火墙或网络限制\n\n`;
                    errorText += `请检查：\n`;
                    errorText += `- 后端服务器是否正常运行: ${BACKEND_SERVER}\n`;
                    errorText += `- 尝试在浏览器中直接访问: ${apiUrl}\n`;
                    errorText += `- 查看浏览器控制台（F12）的详细错误信息`;
                } else {
                    errorText += `⚠️ 未知错误。\n\n`;
                    errorText += `请打开浏览器控制台（F12）查看详细错误信息。`;
                }
                
                // 显示错误信息（保留换行）
                errorMessage.innerHTML = errorText.replace(/\n/g, '<br>');
                errorDiv.classList.add('show');
            }
        }
        
        // 页面加载完成后自动获取内容
        window.addEventListener('DOMContentLoaded', function() {
            console.log('=== 页面加载完成 ===');
            console.log('当前页面URL:', window.location.href);
            console.log('后端服务器:', BACKEND_SERVER);
            console.log('API基础路径:', API_BASE_PATH);
            console.log('开始获取二维码页面...');
            loadQRPage();
        });
        
        // 全局错误处理，捕获未处理的错误
        window.addEventListener('error', function(event) {
            console.error('全局错误:', event.error);
            if (event.error && event.error.message) {
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('error-message');
                if (errorDiv && !errorDiv.classList.contains('show')) {
                    document.getElementById('loading').classList.add('hidden');
                    errorMessage.innerHTML = `发生未处理的错误: ${event.error.message}<br><br>请打开浏览器控制台（F12）查看详细信息。`;
                    errorDiv.classList.add('show');
                }
            }
        });
        
        // 捕获未处理的 Promise 拒绝
        window.addEventListener('unhandledrejection', function(event) {
            console.error('未处理的 Promise 拒绝:', event.reason);
            const errorDiv = document.getElementById('error');
            const errorMessage = document.getElementById('error-message');
            if (errorDiv && !errorDiv.classList.contains('show')) {
                document.getElementById('loading').classList.add('hidden');
                const errorMsg = event.reason && event.reason.message ? event.reason.message : String(event.reason);
                errorMessage.innerHTML = `发生未处理的错误: ${errorMsg}<br><br>请打开浏览器控制台（F12）查看详细信息。`;
                errorDiv.classList.add('show');
            }
        });
        
        // 每30秒自动刷新（可选，取消注释启用）
        // setInterval(loadQRPage, 30000);
    </script>
</body>
</html>

